# import whisper  # Biblioteca para transcri√ß√£o de √°udio
# import torch  # Biblioteca para computa√ß√£o em GPU
# import os  # Biblioteca para manipula√ß√£o de arquivos e diret√≥rios
# from datetime import datetime  # Biblioteca para manipula√ß√£o de datas

# def transcrever_com_nvidia(audio_path, modelo_tamanho="base"):
#     # Fun√ß√£o para transcrever √°udio usando Whisper com suporte a GPU NVIDIA
#     print("Iniciando transcri√ß√£o com GPU NVIDIA...")
    
#     device = "cpu"  # Inicia com fallback para CPU
#     # Tenta configurar o dispositivo para GPU NVIDIA
#     if torch.cuda.is_available():
#         print("GPU detectada. Usando CUDA.")
#         device = "cuda"
#     else:
#         print("GPU NVIDIA n√£o encontrada. Usando CPU.") 

#     try:
#         # Carrega o modelo no dispositivo detectado (GPU ou CPU)
#         model = whisper.load_model(modelo_tamanho, device=device)
        
#         # Configura√ß√µes otimizadas para evitar repeti√ß√£o
#         resultado = model.transcribe(
#             audio_path, 
#             fp16=torch.cuda.is_available(),  # Usa fp16 apenas se CUDA estiver dispon√≠vel
#             language="pt",                   # For√ßa portugu√™s para melhor acur√°cia
            
#             # Par√¢metros para evitar repeti√ß√µes e melhorar a qualidade
#             # Fornece uma lista de temperaturas. O Whisper tentar√° cada uma
#             # at√© encontrar uma que passe nos testes de compress√£o e probabilidade.
#             temperature=(0.0, 0.2, 0.4, 0.6, 0.8),
            
#             # Limiar para a taxa de compress√£o. Ajuda a evitar texto sem sentido e repetitivo.
#             compression_ratio_threshold=2.4,
            
#             # Limiar para a probabilidade m√©dia dos tokens. Evita frases com baixa confian√ßa.
#             logprob_threshold=-0.8,
            
#             best_of=5,                      # Aumentado para mais robustez
#             verbose=True,                   # Mostra detalhes da transcri√ß√£o
#             beam_size=5                     # Usa beam search para melhor precis√£o
#         )
        
#         return resultado
        
#     except Exception as e:
#         print(f"Ocorreu um erro durante a transcri√ß√£o: {e}")
#         return {"text": f"Erro na transcri√ß√£o: {e}"}

# # Exemplo de uso
# if __name__ == "__main__":
#     # Configura√ß√µes
#     arquivo_audio = "testeWebcam.mp3"  # Caminho do seu arquivo de √°udio
#     modelo = "base"               # Tamanho do modelo: tiny, base, small, medium, large
    
#     # Executa a transcri√ß√£o
#     resultado = transcrever_com_nvidia(arquivo_audio, modelo)
    
#     # Extrai o texto transcrito
#     texto_transcrito = resultado.get("text", "").strip()

#     # Exibe os resultados
#     print("\n" + "="*50) # Separador visual
#     print("üìÑ TEXTO TRANSCRITO:") # Separador visual
#     print("="*50) # Separador visual
#     if texto_transcrito: # Verifica se h√° texto transcrito
#         print(texto_transcrito) # Exibe o texto transcrito
#     else: # Caso contr√°rio, informa que n√£o h√° texto
#         print("Nenhum texto foi transcrito ou ocorreu um erro.") # Mensagem de erro
        
#     # Salva a transcri√ß√£o em um arquivo de texto se houver conte√∫do
#     if texto_transcrito:
#         try:
#             # Cria um nome de arquivo com base na data e hora atuais para ser √∫nico
#             data_atual = datetime.now().strftime("%Y-%m-%d_%H-%M-%S") # Formato: YYYY-MM-DD_HH-MM-SS
#             nome_arquivo = f"transcricao_{data_atual}.txt" # Nome do arquivo
#             # Salva o texto transcrito em um arquivo de texto
#             with open(nome_arquivo, "w", encoding="utf-8") as f: # Abre o arquivo para escrita
#                 f.write(texto_transcrito) # Escreve o texto no arquivo
                
#             print(f"\n‚úÖ Transcri√ß√£o salva com sucesso no arquivo: {nome_arquivo}") # Mensagem de sucesso
            
#         except Exception as e: # Captura erros ao salvar o arquivo
#             print(f"\n‚ùå Erro ao salvar o arquivo de transcri√ß√£o: {e}") # Mensagem de erro ao salvar

# c√≥dido do chatgpt para pegar o ultimo arquivo da pasta downloads.

import whisper # Biblioteca para transcri√ß√£o de √°udio
import torch # Biblioteca para computa√ß√£o em GPU
import os # Biblioteca para manipula√ß√£o de arquivos e diret√≥rios
import subprocess # Biblioteca para executar comandos do sistema
import requests # Biblioteca para fazer requisi√ß√µes HTTP
from datetime import datetime # Biblioteca para manipula√ß√£o de datas

# URL do servidor no Raspberry Pi (ajuste o IP e porta conforme necess√°rio)
URL_SERVIDOR = "http://192.168.1.239:8080"  # Exemplo: "http://<IP_DO_RASPBERRY>:8080"

# Fun√ß√£o: baixa automaticamente o arquivo do servidor
def baixar_arquivo(url, destino="download_raspberry"):
    try:
        print(f"‚¨áÔ∏è Iniciando download do servidor: {url}")
        resposta = requests.get(url, stream=True)

        if resposta.status_code != 200: 
            print(f"‚ùå Erro ao conectar no servidor: {resposta.status_code}")
            return None

        # Nome do arquivo
        nome_arquivo = destino
        if "content-disposition" in resposta.headers:
            # Se o servidor enviar cabe√ßalho com nome
            nome_arquivo = resposta.headers["content-disposition"].split("filename=")[-1].strip('"')

        with open(nome_arquivo, "wb") as f:
            for chunk in resposta.iter_content(chunk_size=8192):
                if chunk:
                    f.write(chunk)

        print(f"‚úÖ Download conclu√≠do: {nome_arquivo}")
        return nome_arquivo
    except Exception as e:
        print(f"‚ùå Erro durante o download: {e}")
        return None

# Fun√ß√£o: converte v√≠deo em √°udio MP3 usando ffmpeg
def converter_para_mp3(caminho_arquivo): 
    nome_base, _ = os.path.splitext(caminho_arquivo)
    caminho_mp3 = nome_base + ".mp3"
    try:
        subprocess.run(
            ["ffmpeg", "-y", "-i", caminho_arquivo, "-vn", "-acodec", "mp3", caminho_mp3],
            check=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        print(f"üéµ Arquivo convertido para √°udio: {caminho_mp3}")
        return caminho_mp3
    except Exception as e:
        print(f"‚ùå Erro ao converter o arquivo: {e}")
        return None

# Fun√ß√£o para transcrever √°udio usando Whisper com GPU NVIDIA
def transcrever_com_nvidia(audio_path, modelo_tamanho="base"):
    print("Iniciando transcri√ß√£o com GPU NVIDIA...")

    device = "cpu"
    if torch.cuda.is_available():
        print("GPU detectada. Usando CUDA.")
        device = "cuda"
    else:
        print("GPU NVIDIA n√£o encontrada. Usando CPU.") 

    try:
        model = whisper.load_model(modelo_tamanho, device=device)

        resultado = model.transcribe(
            audio_path,
            fp16=torch.cuda.is_available(),
            language="pt",
            temperature=(0.0, 0.2, 0.4, 0.6, 0.8),
            compression_ratio_threshold=2.4,
            logprob_threshold=-0.8,
            best_of=5,
            verbose=True,
            beam_size=5
        )
        return resultado

    except Exception as e:
        print(f"Ocorreu um erro durante a transcri√ß√£o: {e}")
        return {"text": f"Erro na transcri√ß√£o: {e}"}


if __name__ == "__main__":
    # Faz o download autom√°tico do servidor Raspberry Pi
    arquivo = baixar_arquivo(URL_SERVIDOR)

    if arquivo:
        # Extens√µes aceitas diretamente
        extensoes_audio = [".mp3", ".wav", ".m4a", ".ogg"]
        _, ext = os.path.splitext(arquivo)

        if ext.lower() not in extensoes_audio:
            print("üé¨ Detectado v√≠deo. Convertendo para MP3...")
            arquivo = converter_para_mp3(arquivo)

        if arquivo:
            modelo = "base"
            resultado = transcrever_com_nvidia(arquivo, modelo)
            texto_transcrito = resultado.get("text", "").strip()

            print("\n" + "="*50)
            print("üìÑ TEXTO TRANSCRITO:")
            print("="*50)
            if texto_transcrito:
                print(texto_transcrito)
            else:
                print("Nenhum texto foi transcrito ou ocorreu um erro.")

            if texto_transcrito:
                try:
                    data_atual = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
                    nome_arquivo = f"transcricao_{data_atual}.txt"
                    with open(nome_arquivo, "w", encoding="utf-8") as f:
                        f.write(texto_transcrito)
                    print(f"\n‚úÖ Transcri√ß√£o salva com sucesso no arquivo: {nome_arquivo}")
                except Exception as e:
                    print(f"\n‚ùå Erro ao salvar o arquivo de transcri√ß√£o: {e}")
        else:
            print("‚ùå N√£o foi poss√≠vel processar o arquivo.")
    else:
        print("‚ùå Download n√£o realizado.")
