# import whisper  # Biblioteca para transcri√ß√£o de √°udio
# import torch  # Biblioteca para computa√ß√£o em GPU
# import os  # Biblioteca para manipula√ß√£o de arquivos e diret√≥rios
# from datetime import datetime  # Biblioteca para manipula√ß√£o de datas

# def transcrever_com_nvidia(audio_path, modelo_tamanho="base"):
#     # Fun√ß√£o para transcrever √°udio usando Whisper com suporte a GPU NVIDIA
#     print("Iniciando transcri√ß√£o com GPU NVIDIA...")
    
#     device = "cpu"  # Inicia com fallback para CPU
#     # Tenta configurar o dispositivo para GPU NVIDIA
#     if torch.cuda.is_available():
#         print("GPU detectada. Usando CUDA.")
#         device = "cuda"
#     else:
#         print("GPU NVIDIA n√£o encontrada. Usando CPU.") 

#     try:
#         # Carrega o modelo no dispositivo detectado (GPU ou CPU)
#         model = whisper.load_model(modelo_tamanho, device=device)
        
#         # Configura√ß√µes otimizadas para evitar repeti√ß√£o
#         resultado = model.transcribe(
#             audio_path, 
#             fp16=torch.cuda.is_available(),  # Usa fp16 apenas se CUDA estiver dispon√≠vel
#             language="pt",                   # For√ßa portugu√™s para melhor acur√°cia
            
#             # Par√¢metros para evitar repeti√ß√µes e melhorar a qualidade
#             # Fornece uma lista de temperaturas. O Whisper tentar√° cada uma
#             # at√© encontrar uma que passe nos testes de compress√£o e probabilidade.
#             temperature=(0.0, 0.2, 0.4, 0.6, 0.8),
            
#             # Limiar para a taxa de compress√£o. Ajuda a evitar texto sem sentido e repetitivo.
#             compression_ratio_threshold=2.4,
            
#             # Limiar para a probabilidade m√©dia dos tokens. Evita frases com baixa confian√ßa.
#             logprob_threshold=-0.8,
            
#             best_of=5,                      # Aumentado para mais robustez
#             verbose=True,                   # Mostra detalhes da transcri√ß√£o
#             beam_size=5                     # Usa beam search para melhor precis√£o
#         )
        
#         return resultado
        
#     except Exception as e:
#         print(f"Ocorreu um erro durante a transcri√ß√£o: {e}")
#         return {"text": f"Erro na transcri√ß√£o: {e}"}

# # Exemplo de uso
# if __name__ == "__main__":
#     # Configura√ß√µes
#     arquivo_audio = "testeWebcam.mp3"  # Caminho do seu arquivo de √°udio
#     modelo = "base"               # Tamanho do modelo: tiny, base, small, medium, large
    
#     # Executa a transcri√ß√£o
#     resultado = transcrever_com_nvidia(arquivo_audio, modelo)
    
#     # Extrai o texto transcrito
#     texto_transcrito = resultado.get("text", "").strip()

#     # Exibe os resultados
#     print("\n" + "="*50) # Separador visual
#     print("üìÑ TEXTO TRANSCRITO:") # Separador visual
#     print("="*50) # Separador visual
#     if texto_transcrito: # Verifica se h√° texto transcrito
#         print(texto_transcrito) # Exibe o texto transcrito
#     else: # Caso contr√°rio, informa que n√£o h√° texto
#         print("Nenhum texto foi transcrito ou ocorreu um erro.") # Mensagem de erro
        
#     # Salva a transcri√ß√£o em um arquivo de texto se houver conte√∫do
#     if texto_transcrito:
#         try:
#             # Cria um nome de arquivo com base na data e hora atuais para ser √∫nico
#             data_atual = datetime.now().strftime("%Y-%m-%d_%H-%M-%S") # Formato: YYYY-MM-DD_HH-MM-SS
#             nome_arquivo = f"transcricao_{data_atual}.txt" # Nome do arquivo
#             # Salva o texto transcrito em um arquivo de texto
#             with open(nome_arquivo, "w", encoding="utf-8") as f: # Abre o arquivo para escrita
#                 f.write(texto_transcrito) # Escreve o texto no arquivo
                
#             print(f"\n‚úÖ Transcri√ß√£o salva com sucesso no arquivo: {nome_arquivo}") # Mensagem de sucesso
            
#         except Exception as e: # Captura erros ao salvar o arquivo
#             print(f"\n‚ùå Erro ao salvar o arquivo de transcri√ß√£o: {e}") # Mensagem de erro ao salvar

# c√≥dido do chatgpt para pegar o ultimo arquivo da pasta downloads.
import whisper
import torch
import os
import subprocess
from datetime import datetime

# Fun√ß√£o: pega o √∫ltimo arquivo baixado na pasta Downloads
def pegar_ultimo_downloads():
    pasta_downloads = os.path.join(os.path.expanduser("~"), "Downloads")
    arquivos = [os.path.join(pasta_downloads, f) for f in os.listdir(pasta_downloads)]
    arquivos = [f for f in arquivos if os.path.isfile(f)]
    if not arquivos:
        return None
    return max(arquivos, key=os.path.getctime)

# Fun√ß√£o: converte v√≠deo em √°udio MP3 usando ffmpeg
def converter_para_mp3(caminho_arquivo): 
    nome_base, _ = os.path.splitext(caminho_arquivo) # Remove a extens√£o original
    caminho_mp3 = nome_base + ".mp3" # Define o novo caminho com extens√£o .mp3
    try:
        subprocess.run(
            ["ffmpeg", "-y", "-i", caminho_arquivo, "-vn", "-acodec", "mp3", caminho_mp3], # Comando ffmpeg para convers√£o
            check=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        print(f"üéµ Arquivo convertido para √°udio: {caminho_mp3}")
        return caminho_mp3
    except Exception as e:
        print(f"‚ùå Erro ao converter o arquivo: {e}")
        return None

# Fun√ß√£o para transcrever √°udio usando Whisper com suporte a GPU NVIDIA
def transcrever_com_nvidia(audio_path, modelo_tamanho="base"):
    print("Iniciando transcri√ß√£o com GPU NVIDIA...")

    device = "cpu"
    if torch.cuda.is_available():
        print("GPU detectada. Usando CUDA.")
        device = "cuda"
    else:
        print("GPU NVIDIA n√£o encontrada. Usando CPU.") 

    try:
        model = whisper.load_model(modelo_tamanho, device=device)

        resultado = model.transcribe(
            audio_path,
            fp16=torch.cuda.is_available(),
            language="pt",
            temperature=(0.0, 0.2, 0.4, 0.6, 0.8),
            compression_ratio_threshold=2.4,
            logprob_threshold=-0.8,
            best_of=5,
            verbose=True,
            beam_size=5
        )
        return resultado

    except Exception as e:
        print(f"Ocorreu um erro durante a transcri√ß√£o: {e}")
        return {"text": f"Erro na transcri√ß√£o: {e}"}


if __name__ == "__main__":
    arquivo = pegar_ultimo_downloads() # Pega o √∫ltimo arquivo da pasta Downloads
    
    if arquivo:
        print(f"üìÇ √öltimo arquivo encontrado: {arquivo}") 

        # Extens√µes aceitas diretamente
        extensoes_audio = [".mp3", ".wav", ".m4a", ".ogg"]
        _, ext = os.path.splitext(arquivo)

        if ext.lower() not in extensoes_audio:
            print("üé¨ Detectado v√≠deo. Convertendo para MP3...")
            arquivo = converter_para_mp3(arquivo)

        if arquivo:
            modelo = "base"
            resultado = transcrever_com_nvidia(arquivo, modelo)
            texto_transcrito = resultado.get("text", "").strip()

            print("\n" + "="*50)
            print("üìÑ TEXTO TRANSCRITO:")
            print("="*50)
            if texto_transcrito:
                print(texto_transcrito)
            else:
                print("Nenhum texto foi transcrito ou ocorreu um erro.")

            if texto_transcrito:
                try:
                    data_atual = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
                    nome_arquivo = f"transcricao_{data_atual}.txt"
                    with open(nome_arquivo, "w", encoding="utf-8") as f:
                        f.write(texto_transcrito)
                    print(f"\n‚úÖ Transcri√ß√£o salva com sucesso no arquivo: {nome_arquivo}")
                except Exception as e:
                    print(f"\n‚ùå Erro ao salvar o arquivo de transcri√ß√£o: {e}")
        else:
            print("‚ùå N√£o foi poss√≠vel processar o arquivo.")
    else:
        print("‚ùå Nenhum arquivo encontrado na pasta Downloads.")
